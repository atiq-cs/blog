

<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Notes from Qubit Inc. - Quick Sort</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js"></script><![endif]-->
		<link rel="stylesheet" href="/assets/sass/main.css" />
		<!--[if lte IE 9]><link rel="stylesheet" href="/assets/sass/ie9.css" /><![endif]-->
		<!--[if lte IE 8]><link rel="stylesheet" href="/assets/sass/ie8.css" /><![endif]-->
        

	</head>
	<body>

		<!-- Page Wrapper -->
			<div id="page-wrapper">
				
				<!-- Header -->
				<header id="header">
					<h1><a href="/">Notes from Qubit Inc.</a></h1>
					<nav>
						<a href="#menu">Menu</a>
					</nav>
				</header>

				<!-- Menu -->
				<nav id="menu">
					<div class="inner">
						<h2>Menu</h2>
						<ul class="links">
							        <li><a href="/posts">Archive</a></li>
        <li><a href="/tags">Tags</a></li>
        <li><a href="/about">About Me</a></li>

						</ul>
						<a href="#" class="close">Close</a>
					</div>
				</nav>


    
<section id="banner">
  <div class="inner">
    <h2>Quick Sort</h2>
            <p><em>Published on Thursday, September 14, 2017</em></p>
                    <a role="button" href="/tags/Algorithms" class="button small">Algorithms</a>
                <a role="button" href="/tags/Problem-Solving" class="button small">Problem Solving</a>
                <a role="button" href="/tags/Sorting" class="button small">Sorting</a>
  </div>
</section>

				<!-- Main -->
				<section id="wrapper">
					<section class="wrapper style2">
						<div class="inner">
							

<p>Based on the idea that we can partition an array around a pivot (chosen element of the array), we can put the smaller (than pivot) elements on the left side and place greater elements on the right side of the pivot, then, we keep doing the same thing for the left side and the right side. More details of how this algorithm works is on &quot;How it works&quot; section.</p>
<p><img src="https://github.com/atiq-cs/atiqcs-wp-com/raw/master/images/2017/09/QuickSort-Partitioning.png" class="img-fluid" alt="quick sort with pivot figure" /></p>
<p>Fig: fundamental concept of Quick-Sort, partitioning</p>
<p><strong>Quick sort</strong>, <em>one of the fundamental sorting algorithms of computer science sorts an array efficiently on average</em>.</p>
<p>A few important things about Quick Sort,</p>
<ul>
<li>expected running time θ(n lg n)</li>
<li>sorts in place (does not use additional memory)</li>
<li>works well even in virtual environment</li>
<li>worst case does not depend on any particular input</li>
</ul>
<h2 id="description-of-the-algorithm">Description of the Algorithm</h2>
<p>Steps,</p>
<ul>
<li>Divide</li>
<li>Conquer</li>
<li>Combine</li>
</ul>
<h3 id="divide">Divide</h3>
<p>Partition of the array <code>A[pr..r]</code> into 2 parts, <code>A[p .. q-1]</code> and <code>A[q-1 .. r]</code>. Index <code>q</code> comes from the partitioning procedure.</p>
<p>Pivot can be chosen in a number of ways,</p>
<ul>
<li>The last index as pivot (C.L.R.S - Intro to Algo)</li>
<li>middle element as pivot: <a href="https://www.youtube.com/watch?v=SLauY6PpjW4">Gayle Mcdowell's youtube video on quick sort</a></li>
<li>first index or some other index (can be randomized)</li>
</ul>
<h3 id="conquer">Conquer</h3>
<p>We start with partitioning the array. We sort 2 sub-arrays recursively by calling quick sort on partitions.</p>
<h3 id="combine">Combine</h3>
<p>Each recursive call to 'quick-sort' sorts the particular segment of the array. After recursive calls return the array is already sorted. Therefore, no action is required to be taken on combine step.</p>
<h2 id="how-it-works">How it works</h2>
<p>The idea is that we choose a pivot element from the array. We put all elements less than the pivot to the left side and we put all elements greater than the pivot item to the right side. We consider the left side and the right side as 2 sub-arrays where we apply the same procedure. After recursively applying the mechanism in the end, the array is sorted.</p>
<h3 id="worst-case-of-quick-sort">Worst Case of Quick Sort</h3>
<p>Worst case happens if every call of partition the chosen pivot creates a partition with (n-1) element and 1 element. This can be the case when an array is sorted in reverse order.</p>
<pre><code>For example an array with 5 elements,
 5 4 3 2 1

Steps can be visualized below,
1. QuickSort(A, 0, 4)

Partition procedure chooses A[4] = 1 as pivot. Nothing is smaller than 1 so the
iteration/traversing element does nothing. In the end, it swaps A[4] and A[0]. 
At this stage, the array looks like,
 1 4 3 2 5

and the procedure returns 0. After partition function returns two calls are spawned,
 QuickSort(A, 0, -1)
 QuickSort(A, 1, 4)

2. QuickSort(A, 0, -1) does nothing
3. QuickSort(A, 1, 4) has following input,
 4 3 2 5

its partition procedure chooses A[4] as pivot and returns 4. All elements swap
with themselves; array stays unchanged.

It spawns two quick sorts.
 QuickSort(A, 1, 3)
 QuickSort(A, 5, 4)

4. QuickSort(A, 1, 3) has input as,
 4 3 2

Partition does a swap in the end and leaves 2 in index 1. It returns 1.
it looks like following then,
 2 3 4
 
It spawns two quick sort calls.
 QuickSort(A, 1, 0)
 QuickSort(A, 2, 3)
 
5. QuickSort(A, 5, 4) does nothing and the array is sorted.
6. QuickSort(A, 1, 0) takes no action.
7. QuickSort(A, 2, 3) Partition takes index 3 as pivot. Array stays
unchanged. 3 is returned by Partition. 2 calls are spawned,
 QuickSort(A, 2, 2)
 QuickSort(A, 4, 3)


Worst case of quick sort depends on the partitioning. As we can see index
returned by partition function are,
 0, 4, 1, 3, 2
</code></pre>
<p>It means instead pivot dividing the array into two parts it has traversed through every index of the array.
Therefore, we get O(N) for each call of quick sort. pivot is selected n times.
This gives overall O(n^2) time for quick sort.</p>
<p>The Generic Algorithm written in book, Intro to Algo by C.L.R.S can be applied to sort a part of an array specifying starting index and the ending index. Usually when I write a sorting algorithm we apply to the entire array calling like this,</p>
<pre><code>QuickSort(A);
</code></pre>
<p>Usually in C# or Java languages there is a Length attribute of the array, C has <code>sizeof</code>. Another example input,</p>
<pre><code>5
1 4 2 4 3
</code></pre>
<h3 id="primary-references">Primary References</h3>
<ol>
<li>From the book, <a href="https://dl.acm.org/citation.cfm?id=1614191">Introduction to Algorithm - C.L.R.S</a></li>
</ol>
<ul>
<li>Performance analysis on Section# 7.2</li>
<li>Random Sampling on Section# 7.3</li>
<li>Worst case analysis on Section# 7.4</li>
</ul>
<ol start="2">
<li>CS Stony Brook Dr Rezaul's Lecture</li>
<li>Cracking the Coding Interview, 3rd ed. - Gayle Mcdowell</li>
</ol>



						</div>
					</section>
				
				</section>
				
				<!-- Footer -->
                <footer id="footer">
                    <div class="inner">
    <section>
            <h2>Feeds</h2>
            <ul class="actions">
                <li><a href="/feed.rss" class="button small"><i class="fa fa-rss"></i> RSS Feed</a></li>
                                <li><a href="/feed.atom" class="button small"><i class="fa fa-rss"></i> Atom Feed</a></li>
            </ul>
    </section>
    <section>
    </section>
    <ul class="copyright">
        <li>Copyright © 2020</li>
        <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
        <li><a href="https://wyam.io">Generated by Wyam</a></li>
    </ul>
</div>
                </footer>
			</div>

		<!-- Scripts -->
			<script src="/assets/js/skel.min.js"></script>
			<script src="/assets/js/jquery.min.js"></script>
			<script src="/assets/js/jquery.scrollex.min.js"></script>
			<script src="/assets/js/util.js"></script>
            <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js"></script><![endif]-->
            <script src="/assets/js/main.js"></script>

	</body>

</html>